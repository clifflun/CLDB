import streamlit as st
import pandas as pd
import numpy as np

def pheno2gene(hpo_id):
	hpo = pd.read_csv('/CLDB/util/BEDanno/reference/phenotype_to_genes.txt', sep='\t')
	genes=[]
	out=hpo[hpo['hpo_id']==hpo_id]['gene_symbol'].unique().tolist()
	return out
	
chrom = [i for i in range(1,23)]
chrom.append('X')
chrom.append('Y')

OMIM=pd.read_csv('/CLDB/util/BEDanno/reference/hg19/OMIM_sorted.bed', sep='\t', \
		index_col=False, header=0, names = ['chrom', 'start', 'end', 'gene_symbol', 'disease', 'pheno_key'])
OMIM_syms = OMIM.gene_symbol.unique()
OMIM = OMIM[OMIM.pheno_key.notnull()]
rs=pd.read_csv('/CLDB/util/BEDanno/reference/hg19/RefSeq_sorted.bed', sep='\t', \
		index_col=False, header=0, names= ['chrom', 'start', 'end', 'gene_id'])
rs_syms = rs.gene_id.unique()


def search_filters(db, key):
	if db == 'CLDB_LR':
		metadata = pd.read_csv('/CLDB/meta/meta_LR.tsv', sep='\t', index_col=False)
		if 'hg19' in key: 
			metadata=metadata[metadata['hg19_path'].notnull()]
		elif 'hg38' in key:
			metadata=metadata[metadata['hg38_path'].notnull()]
	else:
		if db == 'CLDB_SR' and 'hg19' in key:
			metadata = pd.read_csv('/CLDB/meta/meta_SR_hg19.tsv', sep='\t', index_col=False)
		elif db == 'CLDB_SR' and 'hg38' in key:
			metadata = pd.read_csv('/CLDB/meta/meta_SR_hg38.tsv', sep='\t', index_col=False)
		elif db == 'GREGoR_SR':
			metadata = pd.read_csv('/CLDB/meta/gregor_meta.tsv', sep='\t', index_col=False)
		if 'CNV' in key:
			metadata=metadata[metadata['MD_path'].notnull()]
		else:
			metadata=metadata[metadata['P2_path'].notnull()]
		

	families = metadata.family.unique()
	pt_ids = metadata.pt_id.unique()
	projects = metadata.project.unique()
	n_sub = len(pt_ids)

	if 'CNV' in key: 
		SV_types = ['HOM_DEL', 'HET_DEL', 'DUP', 'TRP', 'UND', 'MUL_GAIN']
	else: 
		SV_types = ['DUP', 'DEL', 'INV', 'INS', 'BND']

	col1, col2, col3, col4, col5= st.columns(5)
	with col1:
		chrom1 = st.selectbox(
			'Chromosome',
			chrom,
			index=None,
			placeholder='Select Chromosome',
			key=f'chrom1-{key}'
			)

		project = st.multiselect(
		'Project:', 
		projects,
		key=f'project-{key}'
		)

		SD_ol = st.selectbox(
			'SD/gap Overlap',
			['True', 'False'],
			index=None,
			help = 'If SV/CNV call is overlapping >98% with Segmental Duplications or known gaps (UCSC)',
			key=f'SD_ol-{key}'
			)
		if st.checkbox('Filter SV/CNV Length', key=f'svlen-{key}'):
			sv_len_min, sv_len_max = st.slider(
				'   ',
				min_value=0,
				max_value=248387328,  # Adjust the max_value according to your data
				value=(0, 248387328),  # Initial range values
				step=5000,
				key=f'svlen-slider-{key}')
		else: 
			sv_len_min = None
			sv_len_max = None

	with col2:
		start = st.number_input(
			'Left Breakpoint:', 
			value=None, 
			min_value=0,
			key=f'start-{key}')

		is_proband = st.selectbox(
		'Is call from a proband:',
		['True', 'False'],
		index=None,
		key=f'is_proband-{key}')

		cluster_id = st.number_input(
			'Cluster ID:', 
			value=None, 
			min_value=-1,
			key = f'cluster_id-{key}',
			help='SV/CNV calls are clustered using DBSCAN (eps:500, min_sample:2)')

		sv_id = st.text_input(
			'SV ID:',
			value=None,
			key = f'sv_id-{key}',
			help='SV/CNV ID generated by caller')

	with col3:
		end = st.number_input(
			'Right Breakpoint:', 
			value=None, 
			min_value=0,
			key=f'end-{key}')

		pt_id = st.multiselect(
		'Individual ID:',
		pt_ids,
		key=f'pt_id-{key}')

		if 'CGR' in key:
			hpo_list=''
			placeholder=st.empty()
			with placeholder:
				st.markdown("<div style='height:82px;'></div>", unsafe_allow_html=True)
		else:
			hpo_list = st.text_input(
				'HPO terms Search', '',
				key=f'hpo_genes-{key}',
				help='comma-separated HPO terms list (e.g. "HP:0003300, HP:0000200")'
				)
		

	with col4:
		svtype = st.multiselect(
			'SV/CNV Type:',
			SV_types,
			key=f'svtype-{key}'
			)

		family = st.multiselect(
		'Family ID:',
		families,
		help='Results will include all family members',
		key=f'family-{key}'
		)

		if 'CGR' in key:
			gene_list=''
			placeholder=st.empty()
			with placeholder:
				st.markdown("<div style='height:82px;'></div>", unsafe_allow_html=True)
		else:
			gene_list = st.text_input(
				'RefSeq Gene List Search', '',
				key=f'gene_list-{key}',
				help='comma-separated gene list (e.g. "MECP2, DOCK8")'
				)


	with col5:
		if 'CNV' in key or 'CGR' in key:
			genotype=None
			placeholder=st.empty()
			with placeholder:
				st.markdown("<div style='height:82px;'></div>", unsafe_allow_html=True)
		else: 
			genotype = st.selectbox(
				'Genotype of SV/CNV call:', 
				['Homozygous', 'Heterozygous'],
				index=None,
				key=f'genotype-{key}'
				)
		if 'CGR' in key:
			OMIM_sym=None
			placeholder=st.empty()
			with placeholder:
				st.markdown("<div style='height:82px;'></div>", unsafe_allow_html=True)
		else:
			OMIM_sym = st.selectbox(
				'OMIM Disease Genes:',
				OMIM_syms,
				index=None,
				help='OMIM disease causing genes from UCSC (pheno_key 3/4)',
				key=f'OMIMsyms-{key}'
				)
		if 'CGR' in key:
			rs_sym=None
			placeholder=st.empty()
			with placeholder:
				st.markdown("<div style='height:82px;'></div>", unsafe_allow_html=True)
		else:
			rs_sym = st.selectbox(
				'RefSeq Genes:',
				rs_syms,
				index=None,
				help='RefSeq genes from NCBI curated list',
				key=f'rssym-{key}'
				)


	if 'CGR' not in key:
		col6, col7 = st.columns(2)
		with col6: 
			with st.expander('Breakpoint Filters'):	
				if st.checkbox('Left Breakpoint Disrupting Gene',
					help='check if left breakpoint is distrupting NCBI curated gene list',
					key=f'left-bkpt-gene-{key}'):
					disrupt_gene_left = True
				else: 
					disrupt_gene_left = False

				if st.checkbox('Right Breakpoint Disrupting Gene',
					help='check if right breakpoint is distrupting NCBI curated gene list',
					key=f'right-bkpt-gene-{key}'):
					disrupt_gene_right = True
				else: 
					disrupt_gene_right = False


				if st.checkbox('Left Breakpoint In Repeats',
					help='check if left breakpoint is distrupting RepeatMask repeats',
					key=f'left-bkpt-repeat-{key}'):
					disrupt_repeat_left = True
				else: 
					disrupt_repeat_left = False

				if st.checkbox('Right Breakpoint In Repeats',
					help='check if right breakpoint is distrupting RepeatMask repeats',
					key=f'right-bkpt-repeat-{key}'):
					disrupt_repeat_right = True
				else: 
					disrupt_repeat_right = False

			with st.expander('Dosage Sensitivity/Imprinting Filters'):
				if st.checkbox('SV/CNV overlaps haploinsufficient genes (Collins)  ',
					help='HI genes from Collins et al 2022',
					key=f'hi-collins-{key}'):
					pHaplo_collins = True
				else: 
					pHaplo_collins = False

				if st.checkbox('SV/CNV overlaps triplosensitive genes (Collins) ',
					help='TS genes from Collins et al 2022',
					key=f'ts-collins-{key}'):
					pTriplo_collins = True
				else: 
					pTriplo_collins = False

				if st.checkbox('SV/CNV overlaps haploinsufficient genes (ClinGen) ',
					help='HI genes from ClinGen(2024)',
					key=f'hi-clingen-{key}'):
					pHaplo_clingen = True
				else: 
					pHaplo_clingen = False

				if st.checkbox('SV/CNV overlaps triplosensitive genes (ClinGen) ',
					help='TS genes from ClinGen(2024)',
					key=f'ts-clingen-{key}'):
					pTriplo_clingen = True
				else: 
					pTriplo_clingen = False

				if st.checkbox('SV/CNV overlaps DECIPHER regions ',
					help='Syndromes list from DECIPHER',
					key=f'decipher-{key}'):
					decipher = True
				else: 
					decipher = False

				if st.checkbox('SV/CNV overlaps ISCA regions    ',
					help='ISCA regions',
					key=f'isca-{key}'):
					ISCA = True
				else: 
					ISCA = False

				if st.checkbox('SV/CNV overlaps imprinting genes',
					help='geneomic England imprinting genes',
					key=f'imprinting-{key}'):
					imprinting = True
				else: 
					imprinting = False

		with col7: 
			with st.expander('Count/Frequency Filters'):	

				if st.checkbox('Filter pseudo-Database Frequency',
					help='Frequency of number of unique individuals in a cluster in the whole DB',
					key=f'db-freq-{key}'):
											
					db_freq = st.slider(
						' ',
						value=(0.0, 1.0),
						max_value=1.0,
						step=0.0001,
						format='%f',
						key=f'df-freq-slider-{key}')
				else: 
					db_freq = None


				if st.checkbox('Filter pseudo-proband-only Frequency',
					help='Frequency of number of unique probands in a cluster in the whole DB',
					key=f'db-proband-freq-{key}'):
											
					db_freq_proband = st.slider(
						' ',
						value=(0.0, 1.0),
						max_value=1.0,
						step=0.0001,
						format='%f',
						key=f'df-proband-freq-slider-{key}')
				else: 
					db_freq_proband = None
					
				if st.checkbox('Filter pseudo-nonproband-only Frequency',
					help='Frequency of number of unique nonprobands in a cluster in the whole DB',
					key=f'db-nonproband-freq-{key}'):
											
					db_freq_nonproband = st.slider(
						' ',
						value=(0.0, 1.0),
						max_value=1.0,
						step=0.0001,
						format='%f',
						key=f'df-nonproband-freq-slider-{key}')
				else: 
					db_freq_nonproband = None	

				if st.checkbox('Filter Unique Individual Count', 
					help='Number of unique individuals in a cluster in the whole DB',
					key=f'df-count-{key}'):
					count = st.slider(
						'        ',
						value=(1,n_sub),
						max_value=n_sub,
						key=f'df-count-slider-{key}'
						)
				else: 
					count = None

				if st.checkbox('Filter gnomAD Frequency',
					help='gnomAD (hg19-v2, hg38-v4) population frequency (if matched)',
					key=f'gnomad-freq-{key}'):
					gnomad_freq_value=(0.0, 1.0)
					gnomAD_freq = st.slider(
						'',
						value=gnomad_freq_value,
						max_value=1.0,
						step=0.0001,
						format='%f',
						key=f'gnomad-freq-slider-{key}')
				else: 
					gnomAD_freq = None	
				
				if 'hg38' in key:
					if st.checkbox('Filter TopMED Frequency',
						help='TopMED population frequency (if matched)',
						key=f'TopMED-freq-{key}'):
						TopMED_freq_value=(0.0, 1.0)
						TopMED_freq = st.slider(
							'',
							value=TopMED_freq_value,
							max_value=1.0,
							step=0.0001,
							format='%f',
							key=f'TopMED-freq-slider-{key}')
					else: 
						TopMED_freq = None
				else: 
					TopMED_freq = None




				if st.checkbox('Filter RefSeq Count',
					help='Number of NCBI curated RefSeq genes overlapping a call',
					key=f'refseq-count-{key}'):
					RefSeq_min, RefSeq_max = st.slider(
						'',
						min_value=0,
						max_value=1000,  # Adjust the max_value according to your data
						value=(0, 5000),  # Initial range values
						step=1,
						key=f'refseq-slider-{key}'
					)
				else: 
					RefSeq_min = None
					RefSeq_max = None

				if st.checkbox('Filter OMIM Count',
					help='Number of OMIM disease-causing genes overlapping a call',
					key=f'OMIM-count-{key}'):
					OMIM_min, OMIM_max = st.slider(
						'',
						min_value=0,
						max_value=1000,  # Adjust the max_value according to your data
						value=(0, 5000),  # Initial range values
						step=1,
						key=f'OMIM-slider-{key}'
					)
				else: 
					OMIM_min = None
					OMIM_max = None
	else:
		disrupt_gene_left=None
		disrupt_gene_right=None
		disrupt_repeat_left=None
		disrupt_repeat_right=None
		pHaplo_collins=None
		pTriplo_collins=None
		pHaplo_clingen=None
		pTriplo_clingen=None
		decipher=None
		ISCA=None
		imprinting	=None
		db_freq=None
		db_freq_proband=None
		db_freq_nonproband=None
		count=None
		gnomAD_freq=None
		TopMED_freq=None
		RefSeq_min=None
		RefSeq_max=None
		OMIM_min=None
		OMIM_max=None

	num_rows = st.selectbox(
	'Show Number of Rows:',
	[100,500,1000,5000,'All'],
	help='Use lower number of rows to test your query for faster query time',
	key=f'nrows-{key}')

	qry_dict={
		'chrom1': chrom1,
		'start': start,
		'end': end,
		'svtype': svtype,
		'sv_id': sv_id,
		'sv_len_min': sv_len_min, 
		'sv_len_max': sv_len_max,
		'SD_ol': SD_ol, 
		'is_proband': is_proband,
		'count': count,
		'db_freq': db_freq,
		'db_freq_proband': db_freq_proband,
		'db_freq_nonproband': db_freq_nonproband,
		'gnomAD_freq': gnomAD_freq,
		'TopMED_freq': TopMED_freq,
		'project': project, 
		'OMIM_min': OMIM_min,
		'OMIM_max': OMIM_max,
		'RefSeq_min': RefSeq_min,
		'RefSeq_max': RefSeq_max,
		'OMIM_sym': OMIM_sym,
		'rs_sym': rs_sym,
		'rs_list': gene_list,
		'hpo_list': hpo_list,
		'family': family,
		'pt_id': pt_id,
		'num_rows': num_rows,
		'cluster_id': cluster_id,
		'genotype': genotype,
		'disrupt_gene_left': disrupt_gene_left,
		'disrupt_gene_right': disrupt_gene_right,
		'disrupt_repeat_left': disrupt_repeat_left,
		'disrupt_repeat_right': disrupt_repeat_right,
		'pHaplo_collins': pHaplo_collins,
		'pTriplo_collins': pTriplo_collins,
		'pHaplo_clingen': pHaplo_clingen,
		'pTriplo_clingen': pTriplo_clingen,
		'decipher': decipher,
		'ISCA': ISCA,
		'imprinting': imprinting}
	return qry_dict


def search_build(qry_dict, table):
	# Initialize query
	# st.write(qry_dict)
	ref=table.split('_')[-1]
	qry = f'SELECT p.*, m.sex, m.phenotype FROM {table} p JOIN meta_{ref} m ON p.pt_id = m.pt_id WHERE 1=1'

	# Named parameters dictionary
	params = {}

	# Check if hpo_list is not empty, and fetch gene list
	if len(qry_dict['hpo_list']) != 0:
		tmp = []
		for hpo in [x.strip() for x in qry_dict['hpo_list'].split(',')]:
			tmp.append(pheno2gene(hpo))
		out = list(set([x for xs in tmp for x in xs]))
		qry_dict['rs_list'] = ','.join(out)

	# Apply filters and add to query and parameters
	if qry_dict['chrom1'] is not None:
		qry += ' AND chrom1 = :chrom1'
		params['chrom1'] = qry_dict['chrom1']

	if qry_dict['start'] is not None:
		qry += ' AND pos1 >= :start'
		params['start'] = qry_dict['start']

	if qry_dict['end'] is not None:
		qry += ' AND pos2 <= :end'
		params['end'] = qry_dict['end']

	if len(qry_dict['svtype']) != 0:
		svtype_list = qry_dict['svtype']
		placeholders = []
		for i, sv in enumerate(svtype_list):
			key = f"svtype_{i}"
			placeholders.append(f":{key}")
			params[key] = sv
		qry += f" AND SV_TYPE IN ({', '.join(placeholders)})"


	if qry_dict['sv_len_min'] is not None:
		qry += ' AND SV_LEN >= :sv_len_min'
		params['sv_len_min'] = qry_dict['sv_len_min']

	if qry_dict['sv_len_max'] is not None:
		qry += ' AND SV_LEN <= :sv_len_max'
		params['sv_len_max'] = qry_dict['sv_len_max']

	if qry_dict['SD_ol'] == 'True':
		qry += ' AND SD_overlap = :SD_ol'
		params['SD_ol'] = 1
	elif qry_dict['SD_ol'] == 'False':
		qry += ' AND SD_overlap = :SD_ol'
		params['SD_ol'] = 0

	if qry_dict['is_proband'] == 'True':
		qry += ' AND IS_PROBAND = :is_proband'
		params['is_proband'] = 1
	elif qry_dict['is_proband'] == 'False':
		qry += ' AND IS_PROBAND = :is_proband'
		params['is_proband'] = 0

	if qry_dict['count'] is not None:
		count1 = qry_dict['count'][0]
		count2 = qry_dict['count'][1]
		qry += ' AND UNIQUE_PT_COUNT BETWEEN :count1 AND :count2'
		params['count1'] = count1
		params['count2'] = count2

	if qry_dict['db_freq'] is not None:
		pf1 = qry_dict['db_freq'][0]
		pf2 = qry_dict['db_freq'][1]
		qry += ' AND PSEUDO_FREQ BETWEEN :pf1 AND :pf2'
		params['pf1'] = pf1
		params['pf2'] = pf2

	if qry_dict['db_freq_proband'] is not None:
		pf1 = qry_dict['db_freq_proband'][0]
		pf2 = qry_dict['db_freq_proband'][1]
		qry += ' AND proband_only_propensity BETWEEN :pro_pf1 AND :pro_pf2'
		params['pro_pf1'] = pf1
		params['pro_pf2'] = pf2
	
	if qry_dict['db_freq_nonproband'] is not None:
		pf1 = qry_dict['db_freq_nonproband'][0]
		pf2 = qry_dict['db_freq_nonproband'][1]
		qry += ' AND nonproband_only_propensity BETWEEN :nonpro_pf1 AND :nonpro_pf2'
		params['nonpro_pf1'] = pf1
		params['nonpro_pf2'] = pf2
	
	if qry_dict['gnomAD_freq'] is not None:
		gf1 = qry_dict['gnomAD_freq'][0]
		gf2 = qry_dict['gnomAD_freq'][1]
		qry += ' AND gnomAD_AF BETWEEN :gf1 AND :gf2'
		params['gf1'] = gf1
		params['gf2'] = gf2

	if qry_dict['TopMED_freq'] is not None:
		tm1 = qry_dict['TopMED_freq'][0]
		tm2 = qry_dict['TopMED_freq'][1]
		qry += ' AND TopMED_AF BETWEEN :tm1 AND :tm2'
		params['tm1'] = tm1
		params['tm2'] = tm2

	if len(qry_dict['project']) != 0:
		project_list = qry_dict['project']
		placeholders = []
		for i, proj in enumerate(project_list):
			key = f"project_{i}"
			placeholders.append(f":{key}")
			params[key] = proj
		qry += f" AND PROJECT IN ({', '.join(placeholders)})"


	if qry_dict['OMIM_min'] is not None:
		qry += ' AND OMIM_count >= :OMIM_min'
		params['OMIM_min'] = qry_dict['OMIM_min']

	if qry_dict['OMIM_max'] is not None:
		qry += ' AND OMIM_count <= :OMIM_max'
		params['OMIM_max'] = qry_dict['OMIM_max']

	if qry_dict['RefSeq_min'] is not None:
		qry += ' AND RefSeq_Count >= :RefSeq_min'
		params['RefSeq_min'] = qry_dict['RefSeq_min']

	if qry_dict['RefSeq_max'] is not None:
		qry += ' AND RefSeq_Count <= :RefSeq_max'
		params['RefSeq_max'] = qry_dict['RefSeq_max']

	if qry_dict['OMIM_sym'] is not None:
	    gene = qry_dict['OMIM_sym'].strip().upper()
	    qry += ' AND ('
	    qry += (
	        'OMIM_symbol = :OMIM_sym_exact '
	        'OR OMIM_symbol LIKE :OMIM_sym_prefix '
	        'OR OMIM_symbol LIKE :OMIM_sym_suffix '
	        'OR OMIM_symbol LIKE :OMIM_sym_infix'
	    )
	    qry += ')'
	    params['OMIM_sym_exact'] = gene
	    params['OMIM_sym_prefix'] = f"{gene};%"
	    params['OMIM_sym_suffix'] = f"%;{gene}"
	    params['OMIM_sym_infix'] = f"%;{gene};%"

	if qry_dict['rs_sym'] is not None:
		gene = qry_dict['rs_sym'].strip().upper()
		qry += ' AND ('
		qry += (
			'RefSeq_symbol = :rs_sym_exact '
			'OR RefSeq_symbol LIKE :rs_sym_prefix '
			'OR RefSeq_symbol LIKE :rs_sym_suffix '
			'OR RefSeq_symbol LIKE :rs_sym_infix'
		)
		qry += ')'
		params['rs_sym_exact'] = gene
		params['rs_sym_prefix'] = f"{gene};%"
		params['rs_sym_suffix'] = f"%;{gene}"
		params['rs_sym_infix'] = f"%;{gene};%"

	if len(qry_dict['rs_list']) != 0:
		genes = [x.strip().upper() for x in qry_dict['rs_list'].split(',')]
		genes_2 = [genes[i:i + 300] for i in range(0, len(genes), 300)]  # smaller chunks due to OR expansion

		qry += ' AND ('
		param_counter = 0  # ensures unique parameter names

		for group in genes_2:
			qry += '('
			for i, gene in enumerate(group):
				if i > 0:
					qry += ' OR '
				qry += (
					f"RefSeq_symbol = :gene_exact_{param_counter} "
					f"OR RefSeq_symbol LIKE :gene_prefix_{param_counter} "
					f"OR RefSeq_symbol LIKE :gene_suffix_{param_counter} "
					f"OR RefSeq_symbol LIKE :gene_infix_{param_counter}"
				)
				params[f'gene_exact_{param_counter}'] = gene
				params[f'gene_prefix_{param_counter}'] = f"{gene};%"
				params[f'gene_suffix_{param_counter}'] = f"%;{gene}"
				params[f'gene_infix_{param_counter}'] = f"%;{gene};%"
				param_counter += 1
			qry += ') OR '

		qry += 'RefSeq_symbol = :empty_str)'
		params['empty_str'] = ""

	# Family filter
	if len(qry_dict['family']) != 0:
		family_list = qry_dict['family']
		placeholders = []
		for i, fam in enumerate(family_list):
			key = f"family_{i}"
			placeholders.append(f":{key}")
			params[key] = fam
		qry += f" AND FAM_ID IN ({', '.join(placeholders)})"

	# Patient ID filter
	if len(qry_dict['pt_id']) != 0:
		pt_id_list = qry_dict['pt_id']
		placeholders = []
		for i, pid in enumerate(pt_id_list):
			key = f"pt_id_{i}"
			placeholders.append(f":{key}")
			params[key] = pid
		qry += f" AND p.PT_ID IN ({', '.join(placeholders)})"

	if qry_dict['cluster_id'] is not None:
		qry += ' AND CLUSTER_ID = :cluster_id'
		params['cluster_id'] = qry_dict['cluster_id']

	if qry_dict['sv_id']:
		qry += ' AND SV_ID = :sv_id'
		params['sv_id'] = qry_dict['sv_id']
	else: 
		qry_dict.pop('sv_id', None)

	if qry_dict['genotype'] == 'Homozygous':
		qry += ' AND genotype LIKE :genotype'
		params['genotype'] = "1/1"
	elif qry_dict['genotype'] == 'Heterozygous':
		qry += ' AND genotype IN (:genotype_het_0, :genotype_het_1, :genotype_het_2, :genotype_het_3)'
		params['genotype_het_0'] = "0/1"
		params['genotype_het_1'] = "0|1"
		params['genotype_het_2'] = "1/0"
		params['genotype_het_3'] = "1|0"

	bkpt_filters = [qry_dict['disrupt_gene_left'], qry_dict['disrupt_gene_right'], qry_dict['disrupt_repeat_left'], qry_dict['disrupt_repeat_right']]
	if True in bkpt_filters:
		tmp_qry = []
		if qry_dict['disrupt_gene_left']:
			tmp_qry.append('L_RefSeq != 0')
		if qry_dict['disrupt_gene_right']:
			tmp_qry.append('R_RefSeq != 0')
		if qry_dict['disrupt_repeat_left']:
			tmp_qry.append('L_repeatmask != 0')
		if qry_dict['disrupt_repeat_right']:
			tmp_qry.append('R_repeatmask != 0')
		qry += f' AND ({" OR ".join(tmp_qry)})'

	dosage_filters = [qry_dict['pHaplo_collins'], qry_dict['pTriplo_collins'], qry_dict['pHaplo_clingen'], qry_dict['pTriplo_clingen'], qry_dict['decipher'], qry_dict['ISCA'], qry_dict['imprinting']]
	if True in dosage_filters:
		tmp_qry = []
		if qry_dict['pHaplo_collins']:
			tmp_qry.append('collins_HI != 0')
		if qry_dict['pTriplo_collins']:
			tmp_qry.append('collins_TS != 0')
		if qry_dict['pHaplo_clingen']:
			tmp_qry.append('ClinGen_HI != 0')
		if qry_dict['pTriplo_clingen']:
			tmp_qry.append('ClinGen_TS != 0')
		if qry_dict['decipher']:
			tmp_qry.append('DECIPHER != 0')
		if qry_dict['ISCA']:
			tmp_qry.append('ISCA != 0')
		if qry_dict['imprinting']:
			tmp_qry.append('imprinting_genes != 0')
		qry += f' AND ({" OR ".join(tmp_qry)})'

	if qry_dict['num_rows'] == 'All':
		num_rows = 184467440737095516
	else:
		num_rows = qry_dict['num_rows']
	qry += f' LIMIT :num_rows'
	params['num_rows'] = num_rows

	return qry, params


def igv_filters(db, key):
	if db == 'CLDB_LR':
		metadata = pd.read_csv('/CLDB/meta/meta_LR.tsv', sep='\t', index_col=False)
		if 'hg19' in key: 
			metadata=metadata[metadata['hg19_path'].notnull()]
		elif 'hg38' in key:
			metadata=metadata[metadata['hg38_path'].notnull()]
	else:
		if db == 'CLDB_SR' and 'hg19' in key:
			metadata = pd.read_csv('/CLDB/meta/meta_SR_hg19.tsv', sep='\t', index_col=False)
		elif db == 'CLDB_SR' and 'hg38' in key:
			metadata = pd.read_csv('/CLDB/meta/meta_SR_hg38.tsv', sep='\t', index_col=False)
		elif db == 'GREGoR_SR':
			metadata = pd.read_csv('/CLDB/meta/gregor_meta.tsv', sep='\t', index_col=False)
		metadata=metadata[metadata['BAM_path'].notnull()]

	pt_ids = metadata.pt_id.unique()

	pt_id = st.selectbox(
		' ',
		pt_ids,
		index=None,
		placeholder='Select sample',
		key=f'pt_id-{key}')
	return pt_id



def vizCNV_filters(db, key):
	if db == 'CLDB_LR':
		metadata = pd.read_csv('/CLDB/meta/meta_LR.tsv', sep='\t', index_col=False)
		if 'hg19' in key: 
			metadata=metadata[metadata['hg19_path'].notnull()]
		elif 'hg38' in key:
			metadata=metadata[metadata['hg38_path'].notnull()]
	else:
		if db == 'CLDB_SR' and 'hg19' in key:
			metadata = pd.read_csv('/CLDB/meta/meta_SR_hg19.tsv', sep='\t', index_col=False)
		elif db == 'CLDB_SR' and 'hg38' in key:
			metadata = pd.read_csv('/CLDB/meta/meta_SR_hg38.tsv', sep='\t', index_col=False)
		elif db == 'GREGoR_SR':
			metadata = pd.read_csv('/CLDB/meta/gregor_meta.tsv', sep='\t', index_col=False)
		metadata=metadata[metadata['BAM_path'].notnull()]

	pt_ids = metadata.pt_id.unique()
	chrom = [i for i in range(1,23)]
	chrom.append('X')
	chrom.append('Y')

	col1, col2, col3, col4 = st.columns(4)
	with col1:
		chrom1 = st.selectbox(
			'Chromosome',
			chrom,
			index=None,
			placeholder='Select Chromosome',
			key=f'chrom1-{key}'
			)

	with col2:
		start = st.number_input(
			'Left Breakpoint:', 
			value=1, 
			min_value=1,
			key=f'start-{key}')

	with col3:
		end = st.number_input(
			'Right Breakpoint:', 
			value=248387328, 
			min_value=2,
			max_value=248387328,
			key=f'end-{key}')

	with col4:
		pt_id = st.selectbox(
			'Sample ID:',
			pt_ids,
			index=None,
			placeholder='Select sample',
			key=f'pt_id-{key}')
	return chrom1, start, end, pt_id